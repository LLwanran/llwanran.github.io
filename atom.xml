<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>婉然一笑 - Li的兰花指</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://llwanran.github.io/"/>
  <updated>2018-01-16T07:19:47.803Z</updated>
  <id>https://llwanran.github.io/</id>
  
  <author>
    <name>LLwanran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP名词通俗解释</title>
    <link href="https://llwanran.github.io/posts/994796909.html"/>
    <id>https://llwanran.github.io/posts/994796909.html</id>
    <published>2018-01-16T05:31:00.000Z</published>
    <updated>2018-01-16T07:19:47.803Z</updated>
    
    <content type="html"><![CDATA[<h6 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h6><ul><li>CGI(Common Gateway Interface) 是为了保证web server传递过来的数据是标准格式的，方便CGI程序的编写者。</li><li>是个协议，跟进程什么的没关系。</li><li>可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。</li></ul><h6 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h6><ul><li>是用来提高CGI程序性能的。CGI程序反复加载是CGI性能低下的主要原因，如果CGI程序保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over特性等。</li><li>是常驻型的CGI，它可以一直运行，在请求到达时，不会花费时间去fork一个进程来处理。</li><li>是CGI的升级版，一种语言无关的协议，用来沟通程序(如PHP, Python, Java)和Web服务器(Apache2, Nginx), 理论上任何语言编写的程序都可以通过Fastcgi来提供Web服务。</li></ul><h6 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h6><ul><li>（FastCGI Process Manager）大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理（皇上，臣妾真的做不到啊！）所以就出现了一些能够调度php-cgi进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。好了PHP-FPM也是这么个东东，在长时间的发展后，逐渐得到了大家的认可（要知道，前几年大家可是抱怨PHP-FPM稳定性太差的），也越来越流行。</li><li>使用PHP-FPM来控制PHP-CGI的FastCGI进程。在没有PHP-FPM之前，是直接打开php-cgi.exe(win32)、php-cgi进程来处理fastcgi的请求的。或者是用spawn-fcgi或uwsgi类似的fastcgi进程管理软件。PHP-FPM的目的就是解决spawn-fcgi和uwsgi等类似管理器的缺陷，自php5.3以后版本开始被官方加入。</li></ul><h6 id="phpize"><a href="#phpize" class="headerlink" title="phpize"></a>phpize</h6><ul><li>是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块。</li><li>比如你想在原来编译好的php中加入memcached或者ImageMagick等扩展模块，可以使用phpize。</li></ul><h6 id="PECL"><a href="#PECL" class="headerlink" title="PECL"></a>PECL</h6><ul><li>PHP Extension Community Library，它管理着最底层的PHP扩展。这些扩展是用 C 写的。</li></ul><h6 id="PEAR"><a href="#PEAR" class="headerlink" title="PEAR"></a>PEAR</h6><ul><li>PHP Extension and Application Repository，它管理着项目环境的扩展。这些扩展是用 PHP 写的。</li></ul><h6 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h6><ul><li>PHP依赖管理的新时代</li><li>对于现代语言而言，包管理器基本上是标配。Java 有 Maven，Python 有 pip，Ruby 有 gem，Nodejs 有 npm。PHP 的则是 PEAR，不过 PEAR 坑不少：<blockquote><ol><li>依赖处理容易出问题</li><li>配置非常复杂</li><li>难用的命令行接口</li></ol></blockquote></li><li>好在我们有 Composer，PHP依赖管理的利器。它是开源的，使用起来也很简单，提交自己的包也很容易。</li></ul><h6 id="PSR"><a href="#PSR" class="headerlink" title="PSR"></a>PSR</h6><ul><li>PHP Standard Recommendations，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。</li><li>目前已表决通过了 6 套标准，已经得到大部分 PHP 框架的支持和认可。</li></ul><h6 id="SAPI"><a href="#SAPI" class="headerlink" title="SAPI"></a>SAPI</h6><ul><li>Server Application Programming Interface（服务端应用编程端口）</li><li>PHP通过SAPI提供了一组接口，供应用和PHP内核之间进行数据交互。</li></ul><h6 id="PHP-CLI"><a href="#PHP-CLI" class="headerlink" title="PHP CLI"></a>PHP CLI</h6><ul><li>从版本 4.3.0 开始，PHP 提供了一种新类型的 CLI SAPI支持，名为 CLI，意为 Command Line Interface，即命令行接口。</li><li>主要用作 PHP 的开发外壳应用。</li></ul><hr><h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><p><strong>PHP Version 7.1.13</strong> - phpinfo() Configuration</p><ul><li>BCMath 任意精度数学[数学扩展]</li><li>Bzip2 用于透明地读写 bzip2（.bz2）压缩文件[压缩与归档扩展]</li><li>Calendar [日期与时间相关扩展]</li><li>Ctype 字符类型检测[变量与类型相关扩展]</li><li>cURL Client URL 库[其它服务]</li><li>DBA Database (dbm-style) Abstraction Layer[数据库抽象层]</li><li>DOM Document Object Model[XML 操作]</li><li>EXIF 可交换图像信息[图像生成和处理]</li><li>Fileinfo 文件信息[文件系统相关扩展]</li><li>Filter Data Filtering[变量与类型相关扩展]</li><li>FTP 实现了通过 FTP 协议访问文件服务器的客户端[FTP]</li><li>GD 图像处理[GD]</li><li>Gettext 实现了NLS (Native Language Support) API，他可以用来国际化您的PHP程序[国际化与字符编码支持]</li><li>Hash 哈希信息摘要框架[加密扩展]</li><li>iconv 字符集转换[国际化与字符编码支持]</li><li>Json JavaScript对象符号[其它基本扩展]</li><li>LDAP Lightweight Directory Access Protocol[其它服务]</li><li>libxml [XML 操作]</li><li>mbstring 多字节字符串[国际化与字符编码支持]</li><li>MySQLi MySQL增强版扩展[MySQL]</li><li>Mysqlnd MySQL Native Driver[MySQL]</li><li>ODBC [数据库抽象层]</li><li>OpenSSL 对称/非对称加解密，以及 PBKDF2、 PKCS7、 PKCS12、 X509 和其他加密操作[加密扩展]</li><li>PCNTL 进程控制[进程控制扩展]</li><li>PCRE 正则表达式(兼容 Perl)[文本处理]</li><li>PDO PHP 数据对象[数据库抽象层]</li><li>PDO_MYSQL MySQL Functions[PDO 驱动]</li><li>PDO_ODBC ODBC and DB2 Functions[PDO 驱动]</li><li>PDO_SQLITE SQLite Functions[PDO 驱动]</li><li>Phar [压缩与归档扩展]</li><li>POSIX [进程控制扩展]</li><li>Readline 实现了访问 GNU Readline 库的接口[针对命令行的扩展]</li><li>Reflection 反射[变量与类型相关扩展]</li><li>Session Session Handling[Session 扩展]</li><li>shmop Shared Memory[进程控制扩展]</li><li>SimpleXML [XML 操作]</li><li>SOAP [Web 服务]</li><li>Sockets [其它服务]</li><li>SPL PHP标准库 (SPL)[其它基本扩展]</li><li>SQLite3 [针对各数据库系统对应的扩展]</li><li>Tokenizer [其它基本扩展]</li><li>WDDX [XML 操作]</li><li>XML XML 解析器[XML 操作]</li><li>XMLReader [XML 操作]</li><li>XML-RPC [Web 服务]</li><li>XMLWriter [XML 操作]</li><li>XSL [XML 操作]</li><li>Zip [压缩与归档扩展]</li><li>Zlib Zlib Compression [压缩与归档扩展]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;CGI&quot;&gt;&lt;a href=&quot;#CGI&quot; class=&quot;headerlink&quot; title=&quot;CGI&quot;&gt;&lt;/a&gt;CGI&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;CGI(Common Gateway Interface) 是为了保证web server传递过来的数据是标准格式的，方
      
    
    </summary>
    
      <category term="PHP" scheme="https://llwanran.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://llwanran.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>浅析Memcached, Redis, MongoDB三者的区别</title>
    <link href="https://llwanran.github.io/posts/3063279979.html"/>
    <id>https://llwanran.github.io/posts/3063279979.html</id>
    <published>2018-01-15T01:50:00.000Z</published>
    <updated>2018-01-15T06:11:26.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p><ul><li><a href="http://www.redis.cn/commands.html" target="_blank">查看Redis中文命令大全</a></li><li>Redis 负载监控——<a href="https://github.com/NetEaseGame/redis-monitor" target="_blank">redis-monitor</a>，一个 web 可视化的 redis 监控程序。</li><li>Redis 集群迁移工具 <a href="https://github.com/vipshop/redis-migrate-tool" target="_blank">Redis-Migrate-Tool</a>，基于redis复制，快速，稳定。</li><li><a href="https://www.jianshu.com/p/be32f8b681cd" target="_blank">优酷土豆的Redis服务平台化之路</a></li><li><a href="https://www.jianshu.com/p/ee2aa7fe341b" target="_blank">Redis中国用户组|唯品会Redis cluster大规模生产实践</a></li></ul><p><strong><font color="green">Redis的优点：</font></strong></p><blockquote><ol><li>支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）。</li><li>支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。</li><li>支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。</li><li>单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。</li><li>支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。</li><li>支持简单的事务需求，但业界使用场景很少，并不成熟。</li></ol></blockquote><p><strong><font color="red">Redis的局限性：</font></strong></p><blockquote><ol><li>Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。<br>支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。</li><li>Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。</li><li>Mc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。比如redis的keys pattern这种匹配操作，对redis的性能是灾难。</li></ol></blockquote><p><img src="/images/pasted-2.png" alt="upload successful"></p><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。</p><p><strong><font color="green">Memcached的优点：</font></strong></p><blockquote><ol><li>Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。</li><li>支持直接配置为session handle。</li></ol></blockquote><p><strong><font color="red">Memcached的局限性：</font></strong></p><blockquote><ol><li>只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。</li><li>无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。</li><li>无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。</li><li>Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。</li></ol></blockquote><p><img src="/images/pasted-1.png" alt="upload successful"></p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>是一个基于分布式文件存储的数据库，文档型的非关系型数据库，与上面两者不同。</p><p>先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。</p><p>这些数据具备自述性（self-describing），呈现分层的树状数据结构。redis可以用hash存放简单关系型数据。</p><p>MongoDB存放json格式数据。</p><p>适合场景：事件记录、内容管理或者博客平台，比如评论系统。</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><hr><h6 id="Redis与Memcached的比较"><a href="#Redis与Memcached的比较" class="headerlink" title="Redis与Memcached的比较"></a>Redis与Memcached的比较</h6><blockquote><p>1、<strong>数据类型支持不同</strong></p></blockquote><p>与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。Redis内部使用一个redisObject对象来表示所有的key和value。</p><blockquote><p>2、<strong>内存管理机制不同</strong></p></blockquote><p>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。</p><p>当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。</p><p>这种特性使得Redis可以保持超过其机器本身内存大小的数据。当然，机器本身的内存必须要能够保持所有的key，毕竟这些数据是不会进行swap操作的。同时由于Redis将内存中的数据swap到磁盘中的时候，提供服务的主线程和进行swap操作的子线程会共享这部分内存，所以如果更新需要swap的数据，Redis将阻塞这个操作，直到子线程完成swap操作后才可以进行修改。</p><p>当从Redis中读取数据的时候，如果读取的key对应的value不在内存中，那么Redis就需要从swap文件中加载相应数据，然后再返回给请求方。 这里就存在一个I/O线程池的问题。在默认的情况下，Redis会出现阻塞，即完成所有的swap文件加载后才会相应。这种策略在客户端的数量较小，进行批量操作的时候比较合适。但是如果将Redis应用在一个大型的网站应用程序中，这显然是无法满足大并发的情况的。所以Redis运行我们设置I/O线程池的大小，对需要从swap文件中加载相应数据的读取请求进行并发操作，减少阻塞的时间。</p><blockquote><p>3、<strong>数据持久化支持</strong></p></blockquote><p>Redis虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB快照和AOF日志。而memcached是不支持数据持久化操作的。</p><blockquote><p>4、<strong>集群管理的不同</strong></p></blockquote><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p><p><font color="red">Memcached本身并不支持分布式</font>，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。</p><p><strong>结论</strong></p><ul><li><font color="red">没有必要过多的关心性能，因为二者的性能都已经足够高了。</font>由于Redis只使用单核，而Memcached可以使用多核，所以在比较上，平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。说了这么多，结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。（比如瓶颈可能会在网卡）</li><li>如果要说内存使用效率，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。当然，这和你的应用场景和数据特性有关。</li><li>如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis，因为这两个特性Memcached都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis也是明智的。</li><li>当然，最后还得说到你的具体应用需求。Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果你需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h3&gt;&lt;p&gt;是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构
      
    
    </summary>
    
    
      <category term="nosql" scheme="https://llwanran.github.io/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>javascript中模块的发展历程</title>
    <link href="https://llwanran.github.io/posts/1099660432.html"/>
    <id>https://llwanran.github.io/posts/1099660432.html</id>
    <published>2018-01-06T09:29:00.000Z</published>
    <updated>2018-01-15T06:46:04.836Z</updated>
    
    <content type="html"><![CDATA[<h6 id="一、模块的重要性"><a href="#一、模块的重要性" class="headerlink" title="一、模块的重要性"></a>一、模块的重要性</h6><p>Javascript不是一种模块化编程语言，它不支持”类”（class），更别说”模块”（module）了。<br>开发者们做了很多努力，在现有的运行环境中，实现”模块”的效果。</p><h6 id="没有模块的日子里"><a href="#没有模块的日子里" class="headerlink" title="没有模块的日子里"></a>没有模块的日子里</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后果：</p><p>全局变量的灾难；<br>函数命名冲突；<br>依赖关系不好管理。</p><h6 id="js模块的前身（为了解决以上问题）"><a href="#js模块的前身（为了解决以上问题）" class="headerlink" title="js模块的前身（为了解决以上问题）"></a>js模块的前身（为了解决以上问题）</h6><p><strong>1. 面对对象的写法：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a:<span class="number">1</span>,</span><br><span class="line">b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>优点：<br>1、解决了变量污染的问题；<br>2、保证模块名唯一即可，建立同一模块内的成员的关系。<br>缺点：<br>1、暴露所有模块成员，内部状态可以被外部任意改写。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.a =<span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p><strong>2. 匿名自执行函数：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">a:<span class="number">1</span>,</span><br><span class="line">b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>优点：<br>1、解决暴露所有模块成员，内部状态可以被外部任意改写的问题。<br>缺点：<br>1、所需依赖还是得外部提前提供。</p><h6 id="二、commonJS"><a href="#二、commonJS" class="headerlink" title="二、commonJS"></a>二、commonJS</h6><p>2009年，对js是历史性的一年，nodeJS横空出世，让js跑在服务端，如果说js在浏览器上面可以没有模块，但是在服务端没有模块的思想是万万不能容忍的。<br>由Mozilla 的工程师 Kevin Dangoor 在2009年1月创建了commonJS规范。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建模块 one.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">a: a,</span><br><span class="line">b: b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加载模块 two.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="built_in">require</span>(<span class="string">'./one.js'</span>);</span><br><span class="line">x.b();</span><br></pre></td></tr></table></figure></p><p>优点：<br>1、所有代码都运行在模块作用域，不会污染全局作用域；<br>2、独立性是模块的重要特点就，模块内部最好不与程序的其他部分直接交互；<br>3、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存；<br>4、模块加载的顺序，按照其在代码中出现的顺序。<br>node推广了commonJS规范，但是在浏览器中又出现了很多问题<br>问题：<br>浏览器资源的加载方式与服务端完全不同。服务端require一个模块，直接就从硬盘或者内存中读取了，消耗的时间可以忽略。而浏览器则不同，需要从服务端来下载这个文件，然后运行里面的代码才能得到API，需要花费一个http请求，也就是说，require后面的一行代码，需要资源请求完成才能执行。<br>由于浏览器端是以插入script标签的形式来加载资源的（ajax方式不行，有跨域问题）没办法让代码同步执行，所以像commonjs那样的写法会直接报错。<br>这意味着要想适应浏览器，规范还要改进！！！<br>一个<a href="http://wiki.commonjs.org/wiki/Modules/Wrappings" target="_blank">Modules/Wrappings</a>规范出现了。</p><h6 id="三、AMD"><a href="#三、AMD" class="headerlink" title="三、AMD"></a>三、AMD</h6><p>经过一番谈论、修改（过程忽略），AMD思想出现了…<br>AMD（Asynchronous Module Definition）：</p><ul><li>异步模块定义规范制定了定义模块的规则，这样模块和模块的依赖可以被异步加载。这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题）。</li><li>依赖前置，预执行（异步加载：依赖先执行，依赖必须一开始就写好，会先尽早地执行(依赖)模块 。换句话说，所有的require都被提前执行（require 可以是全局或局部 ）。</li><li>相关Api(简单实例):<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义和暴露模块</span></span><br><span class="line">define(<span class="string">"xxx"</span>, [<span class="string">"xxx"</span>, <span class="string">"xxx"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">x, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ... ;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"xxx"</span>, <span class="string">"../xxx"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">xxx, xxx</span>) </span>&#123;</span><br><span class="line">xxxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>具体Api请参见：<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank">AMD (中文版)</a></p><hr><p><strong>RequireJS</strong><br>说完AMD,就不得不提把AMD在浏览器实现的RequireJS。<br>RequireJS是一个JavaScript文件和模块加载器,采用AMD规范。<br>参考文件：<a href="http://requirejs.org/docs/start.html" target="_blank">RequireJS</a></p><h6 id="三、CMD"><a href="#三、CMD" class="headerlink" title="三、CMD"></a>三、CMD</h6><p>CMD（Common Module Definition）:</p><ul><li>CMD更贴近 CommonJS Modules/1.1 和 Node Modules 规范，一个模块就是一个文件；</li><li>它推崇依赖就近，想什么时候 require 就什么时候加载，实现了懒加载（延迟执行 ）；</li><li>它也没有全局 require， 每个API都简单纯粹；</li><li>不过RequireJS从2.0开始，也改成可以延迟执行。</li><li>相关Api(简单实例):<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义和暴露模块</span></span><br><span class="line">define(<span class="string">'xxx'</span>, [<span class="string">'xxx'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">xxx, xxx, xxx</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ... ;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123; </span><br><span class="line"><span class="comment">// 获取模块 a 的接口</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>); </span><br><span class="line"><span class="comment">// 调用模块 a 的方法</span></span><br><span class="line">a.doSomething(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>seaJS</strong></p><ul><li>SeaJS遵循的CMD,将CMD在浏览器中实现；</li><li>SeaJS 是一个模块加载器;</li><li>借鉴了 RequireJS 的不少东西</li></ul><p><a href="http://www.zhangxinxu.com/sp/seajs/" target="_blank">seajs官网</a></p><p><strong>其他</strong></p><p><strong>UMD</strong></p><p>既然CommonJs和AMD风格一样流行，似乎缺少一个统一的规范。所以人们产生了这样的需求，希望有支持两种风格的“通用”模式，于是通用模块规范（UMD）诞生了。</p><p><strong>es6 modules</strong></p><ul><li>ES6自带了模块化， 也是JS第一次支持module；</li></ul><p><strong>后记</strong></p><p>本文主要记述模块的思想在浏览器的实现过程，不是一篇详细的Api教程。</p><blockquote><p>来源：<a href="http://blog.sooyoung.cn/2017/12/01/module/#more" target="_blank" rel="noopener">http://blog.sooyoung.cn/2017/12/01/module/#more</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;一、模块的重要性&quot;&gt;&lt;a href=&quot;#一、模块的重要性&quot; class=&quot;headerlink&quot; title=&quot;一、模块的重要性&quot;&gt;&lt;/a&gt;一、模块的重要性&lt;/h6&gt;&lt;p&gt;Javascript不是一种模块化编程语言，它不支持”类”（class），更别说”模块”（m
      
    
    </summary>
    
      <category term="前端" scheme="https://llwanran.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="模块" scheme="https://llwanran.github.io/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
</feed>
